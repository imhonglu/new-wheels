<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@imhonglu/json-schema](./json-schema.md) &gt; [createSchemaClass](./json-schema.createschemaclass.md)

## createSchemaClass() function

Creates a class based on a JSON schema definition that provides type-safe instantiation and validation.

**Signature:**

```typescript
export declare function createSchemaClass<const T extends SchemaInput>(schemaDefinition: InferSchema<T>): {
    new (data: InferSchemaInputType<T>): InferSchemaType<T> extends Exclude<object, null> ? T extends {
        type: unknown;
    } ? InferSchemaType<T> : {
        data: InferSchemaType<T>;
    } : {
        data: InferSchemaType<T>;
    };
    parse: <T_1>(this: {
        new (data: InferSchemaInputType<T_1>): T_1;
    }, data: unknown) => T_1;
} & Schema<T>;
```

## Parameters

<table><thead><tr><th>

Parameter


</th><th>

Type


</th><th>

Description


</th></tr></thead>
<tbody><tr><td>

schemaDefinition


</td><td>

[InferSchema](./json-schema.inferschema.md)<!-- -->&lt;T&gt;


</td><td>

The JSON schema definition that describes the structure and validation rules


</td></tr>
</tbody></table>
**Returns:**

{ new (data: [InferSchemaInputType](./json-schema.inferschemainputtype.md)<!-- -->&lt;T&gt;): [InferSchemaType](./json-schema.inferschematype.md)<!-- -->&lt;T&gt; extends Exclude&lt;object, null&gt; ? T extends { type: unknown; } ? [InferSchemaType](./json-schema.inferschematype.md)<!-- -->&lt;T&gt; : { data: [InferSchemaType](./json-schema.inferschematype.md)<!-- -->&lt;T&gt;; } : { data: [InferSchemaType](./json-schema.inferschematype.md)<!-- -->&lt;T&gt;; }; parse: &lt;T\_1&gt;(this: { new (data: [InferSchemaInputType](./json-schema.inferschemainputtype.md)<!-- -->&lt;T\_1&gt;): T\_1; }, data: unknown) =&gt; T\_1; } &amp; [Schema](./json-schema.schema.md)<!-- -->&lt;T&gt;

A class constructor with the following features: - Type-safe instantiation with schema validation - Static `parse()` method for validating unknown data - Proxy-based property access to the underlying data - Automatic schema validation and default value application - JSON serialization support via `toJSON()`

## Exceptions

- [ValidationFailedError](./json-schema.validationfailederror.md) When the provided data doesn't match the schema during instantiation or parsing

## Example 1

Simple schema

```typescript
class Person extends createSchemaClass({
  type: "object",
  properties: {
    name: { type: "string" },
    deletedAt: {
      type: ["string", "null"],
      default: null,
    },
  },
  required: ["name"],
}) {}

const person = new Person({ name: "John" }); // Person
const person2 = Person.parse('{ "name": "John" }'); // Person
const person3 = Person.safeParse('{ "name": "John" }'); // SafeResult<Person>
```

## Example 2

Complex schema

```typescript
class Person extends createSchemaClass({
  type: "object",
  properties: {
    name: { type: "string" },
    address: {
      type: "object",
      properties: {
        street: { type: "string" },
        city: { type: "string" },
        zip: { type: "string" },
      },
      required: ["street"],
    },
    deletedAt: {
      type: ["string", "null"],
      default: null,
    },
  },
  required: ["name"],
}) {}
```

## Example 3

Nested schema

```typescript
class Address extends createSchemaClass({
  type: "object",
  properties: {
    street: { type: "string" },
    city: { type: "string" },
    zip: { type: "string" },
  },
  required: ["street"],
}) {}

class Person extends createSchemaClass({
  type: "object",
  properties: {
    name: { type: "string" },
    address: Address,
    deletedAt: {
      type: ["string", "null"],
      default: null,
    },
  },
  required: ["name"],
}) {}
```

