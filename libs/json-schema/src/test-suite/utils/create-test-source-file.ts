import { readFile } from "node:fs/promises";
import { basename } from "node:path";
import { createVarExpression, createVarStatement } from "@imhonglu/build-tools";
import { kebabCase } from "@imhonglu/toolkit";
import ts from "typescript";
import type { TestGroup } from "../types/test-group.js";

const identifier = {
	vitest: ts.factory.createStringLiteral("vitest"),
	describe: ts.factory.createIdentifier("describe"),
	test: ts.factory.createIdentifier("test"),
	expect: ts.factory.createIdentifier("expect"),
	schemaClass: ts.factory.createIdentifier("Schema"),
	schemaClassImport: ts.factory.createStringLiteral("../schema.js"),
	schemaVariable: ts.factory.createIdentifier("schema"),
	instanceVariable: ts.factory.createIdentifier("instance"),
};

async function readTestGroups(filePath: string): Promise<TestGroup[]> {
	return readFile(filePath, "utf-8").then(JSON.parse);
}

export async function createTestSourceFile(filePath: string) {
	const statements: ts.Statement[] = [];

	const vitestImportStatement = ts.factory.createImportDeclaration(
		undefined,
		ts.factory.createImportClause(
			false,
			undefined,
			ts.factory.createNamedImports([
				ts.factory.createImportSpecifier(false, undefined, identifier.describe),
				ts.factory.createImportSpecifier(false, undefined, identifier.test),
				ts.factory.createImportSpecifier(false, undefined, identifier.expect),
			]),
		),
		identifier.vitest,
	);

	statements.push(
		ts.addSyntheticLeadingComment(
			vitestImportStatement,
			ts.SyntaxKind.MultiLineCommentTrivia,
			" This file is automatically generated. Do not edit this file. ",
			true,
		),
	);

	const schemaClassImportStatement = ts.factory.createImportDeclaration(
		undefined,
		ts.factory.createImportClause(
			false,
			undefined,
			ts.factory.createNamedImports([
				ts.factory.createImportSpecifier(
					false,
					undefined,
					identifier.schemaClass,
				),
			]),
		),
		identifier.schemaClassImport,
	);

	statements.push(schemaClassImportStatement);

	for (const { description, tests, schema } of await readTestGroups(filePath)) {
		const describeBlock: ts.Statement[] = [
			// schema variable declaration
			createVarStatement(identifier.schemaVariable, schema),
		];

		for (const test of tests) {
			const schemaInstanceStatement = createVarStatement(
				identifier.instanceVariable,
				ts.factory.createVariableDeclaration(
					identifier.instanceVariable,
					undefined,
					undefined,
					ts.factory.createNewExpression(identifier.schemaClass, undefined, [
						identifier.schemaVariable,
					]),
				),
			);

			const expectStatement = ts.factory.createExpressionStatement(
				ts.factory.createCallExpression(
					ts.factory.createPropertyAccessExpression(
						ts.factory.createCallExpression(identifier.expect, undefined, [
							ts.factory.createCallExpression(
								ts.factory.createPropertyAccessExpression(
									identifier.instanceVariable,
									ts.factory.createIdentifier("validate"),
								),
								undefined,
								[createVarExpression(test.data)],
							),
						]),
						ts.factory.createIdentifier(
							test.valid ? "toBeTruthy" : "toBeFalsy",
						),
					),
					undefined,
					[],
				),
			);

			const block = ts.factory.createBlock(
				[schemaInstanceStatement, expectStatement],
				true,
			);

			describeBlock.push(
				ts.factory.createExpressionStatement(
					ts.factory.createCallExpression(identifier.test, undefined, [
						ts.factory.createStringLiteral(test.description),
						ts.factory.createArrowFunction(
							undefined,
							undefined,
							[],
							undefined,
							undefined,
							block,
						),
					]),
				),
			);
		}

		// describe
		statements.push(
			ts.factory.createExpressionStatement(
				ts.factory.createCallExpression(identifier.describe, undefined, [
					ts.factory.createStringLiteral(description),
					ts.factory.createArrowFunction(
						undefined,
						undefined,
						[],
						undefined,
						ts.factory.createToken(ts.SyntaxKind.EqualsGreaterThanToken),
						ts.factory.createBlock(describeBlock, true),
					),
				]),
			),
		);
	}

	const sourceFile = ts.factory.createSourceFile(
		statements,
		ts.factory.createToken(ts.SyntaxKind.EndOfFileToken),
		ts.NodeFlags.None,
	);

	sourceFile.fileName = `${kebabCase(basename(filePath, ".json"))}.test.ts`;

	return sourceFile;
}
