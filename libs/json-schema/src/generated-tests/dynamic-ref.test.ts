/* This file is automatically generated. Do not edit this file. */
import { describe, expect, test } from "vitest";
import { Schema } from "../schema.js";
describe("A $dynamicRef to a $dynamicAnchor in the same schema resource behaves like a normal $ref to an $anchor", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/dynamicRef-dynamicAnchor-same-schema/root",
    type: "array",
    items: { $dynamicRef: "#items" },
    $defs: { foo: { $dynamicAnchor: "items", type: "string" } },
  };
  test("An array of strings is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", "bar"])).toBeTruthy();
  });
  test("An array containing non-strings is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", 42])).toBeFalsy();
  });
});
describe("A $dynamicRef to an $anchor in the same schema resource behaves like a normal $ref to an $anchor", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/dynamicRef-anchor-same-schema/root",
    type: "array",
    items: { $dynamicRef: "#items" },
    $defs: { foo: { $anchor: "items", type: "string" } },
  };
  test("An array of strings is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", "bar"])).toBeTruthy();
  });
  test("An array containing non-strings is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", 42])).toBeFalsy();
  });
});
describe("A $ref to a $dynamicAnchor in the same schema resource behaves like a normal $ref to an $anchor", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/ref-dynamicAnchor-same-schema/root",
    type: "array",
    items: { $ref: "#items" },
    $defs: { foo: { $dynamicAnchor: "items", type: "string" } },
  };
  test("An array of strings is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", "bar"])).toBeTruthy();
  });
  test("An array containing non-strings is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", 42])).toBeFalsy();
  });
});
describe("A $dynamicRef resolves to the first $dynamicAnchor still in scope that is encountered when the schema is evaluated", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/typical-dynamic-resolution/root",
    $ref: "list",
    $defs: {
      foo: { $dynamicAnchor: "items", type: "string" },
      list: {
        $id: "list",
        type: "array",
        items: { $dynamicRef: "#items" },
        $defs: {
          items: {
            $comment:
              "This is only needed to satisfy the bookending requirement",
            $dynamicAnchor: "items",
          },
        },
      },
    },
  };
  test("An array of strings is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", "bar"])).toBeTruthy();
  });
  test("An array containing non-strings is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", 42])).toBeFalsy();
  });
});
describe("A $dynamicRef without anchor in fragment behaves identical to $ref", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/dynamicRef-without-anchor/root",
    $ref: "list",
    $defs: {
      foo: { $dynamicAnchor: "items", type: "string" },
      list: {
        $id: "list",
        type: "array",
        items: { $dynamicRef: "#/$defs/items" },
        $defs: {
          items: {
            $comment:
              "This is only needed to satisfy the bookending requirement",
            $dynamicAnchor: "items",
            type: "number",
          },
        },
      },
    },
  };
  test("An array of strings is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", "bar"])).toBeFalsy();
  });
  test("An array of numbers is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate([24, 42])).toBeTruthy();
  });
});
describe("A $dynamicRef with intermediate scopes that don't include a matching $dynamicAnchor does not affect dynamic scope resolution", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/dynamic-resolution-with-intermediate-scopes/root",
    $ref: "intermediate-scope",
    $defs: {
      foo: { $dynamicAnchor: "items", type: "string" },
      "intermediate-scope": { $id: "intermediate-scope", $ref: "list" },
      list: {
        $id: "list",
        type: "array",
        items: { $dynamicRef: "#items" },
        $defs: {
          items: {
            $comment:
              "This is only needed to satisfy the bookending requirement",
            $dynamicAnchor: "items",
          },
        },
      },
    },
  };
  test("An array of strings is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", "bar"])).toBeTruthy();
  });
  test("An array containing non-strings is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", 42])).toBeFalsy();
  });
});
describe("An $anchor with the same name as a $dynamicAnchor is not used for dynamic scope resolution", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/dynamic-resolution-ignores-anchors/root",
    $ref: "list",
    $defs: {
      foo: { $anchor: "items", type: "string" },
      list: {
        $id: "list",
        type: "array",
        items: { $dynamicRef: "#items" },
        $defs: {
          items: {
            $comment:
              "This is only needed to satisfy the bookending requirement",
            $dynamicAnchor: "items",
          },
        },
      },
    },
  };
  test("Any array is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", 42])).toBeTruthy();
  });
});
describe("A $dynamicRef without a matching $dynamicAnchor in the same schema resource behaves like a normal $ref to $anchor", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/dynamic-resolution-without-bookend/root",
    $ref: "list",
    $defs: {
      foo: { $dynamicAnchor: "items", type: "string" },
      list: {
        $id: "list",
        type: "array",
        items: { $dynamicRef: "#items" },
        $defs: {
          items: {
            $comment:
              "This is only needed to give the reference somewhere to resolve to when it behaves like $ref",
            $anchor: "items",
          },
        },
      },
    },
  };
  test("Any array is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", 42])).toBeTruthy();
  });
});
describe("A $dynamicRef with a non-matching $dynamicAnchor in the same schema resource behaves like a normal $ref to $anchor", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/unmatched-dynamic-anchor/root",
    $ref: "list",
    $defs: {
      foo: { $dynamicAnchor: "items", type: "string" },
      list: {
        $id: "list",
        type: "array",
        items: { $dynamicRef: "#items" },
        $defs: {
          items: {
            $comment:
              "This is only needed to give the reference somewhere to resolve to when it behaves like $ref",
            $anchor: "items",
            $dynamicAnchor: "foo",
          },
        },
      },
    },
  };
  test("Any array is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(["foo", 42])).toBeTruthy();
  });
});
describe("A $dynamicRef that initially resolves to a schema with a matching $dynamicAnchor resolves to the first $dynamicAnchor in the dynamic scope", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/relative-dynamic-reference/root",
    $dynamicAnchor: "meta",
    type: "object",
    properties: { foo: { const: "pass" } },
    $ref: "extended",
    $defs: {
      extended: {
        $id: "extended",
        $dynamicAnchor: "meta",
        type: "object",
        properties: { bar: { $ref: "bar" } },
      },
      bar: {
        $id: "bar",
        type: "object",
        properties: { baz: { $dynamicRef: "extended#meta" } },
      },
    },
  };
  test("The recursive part is valid against the root", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "pass", bar: { baz: { foo: "pass" } } }),
    ).toBeTruthy();
  });
  test("The recursive part is not valid against the root", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "pass", bar: { baz: { foo: "fail" } } }),
    ).toBeFalsy();
  });
});
describe("A $dynamicRef that initially resolves to a schema without a matching $dynamicAnchor behaves like a normal $ref to $anchor", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/relative-dynamic-reference-without-bookend/root",
    $dynamicAnchor: "meta",
    type: "object",
    properties: { foo: { const: "pass" } },
    $ref: "extended",
    $defs: {
      extended: {
        $id: "extended",
        $anchor: "meta",
        type: "object",
        properties: { bar: { $ref: "bar" } },
      },
      bar: {
        $id: "bar",
        type: "object",
        properties: { baz: { $dynamicRef: "extended#meta" } },
      },
    },
  };
  test("The recursive part doesn't need to validate against the root", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "pass", bar: { baz: { foo: "fail" } } }),
    ).toBeTruthy();
  });
});
describe("multiple dynamic paths to the $dynamicRef keyword", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/dynamic-ref-with-multiple-paths/main",
    if: {
      properties: { kindOfList: { const: "numbers" } },
      required: ["kindOfList"],
    },
    then: { $ref: "numberList" },
    else: { $ref: "stringList" },
    $defs: {
      genericList: {
        $id: "genericList",
        properties: { list: { items: { $dynamicRef: "#itemType" } } },
        $defs: {
          defaultItemType: {
            $comment: "Only needed to satisfy bookending requirement",
            $dynamicAnchor: "itemType",
          },
        },
      },
      numberList: {
        $id: "numberList",
        $defs: { itemType: { $dynamicAnchor: "itemType", type: "number" } },
        $ref: "genericList",
      },
      stringList: {
        $id: "stringList",
        $defs: { itemType: { $dynamicAnchor: "itemType", type: "string" } },
        $ref: "genericList",
      },
    },
  };
  test("number list with number values", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ kindOfList: "numbers", list: [1.1] }),
    ).toBeTruthy();
  });
  test("number list with string values", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ kindOfList: "numbers", list: ["foo"] }),
    ).toBeFalsy();
  });
  test("string list with number values", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ kindOfList: "strings", list: [1.1] }),
    ).toBeFalsy();
  });
  test("string list with string values", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ kindOfList: "strings", list: ["foo"] }),
    ).toBeTruthy();
  });
});
describe("after leaving a dynamic scope, it is not used by a $dynamicRef", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/dynamic-ref-leaving-dynamic-scope/main",
    if: {
      $id: "first_scope",
      $defs: {
        thingy: {
          $comment: "this is first_scope#thingy",
          $dynamicAnchor: "thingy",
          type: "number",
        },
      },
    },
    then: {
      $id: "second_scope",
      $ref: "start",
      $defs: {
        thingy: {
          $comment:
            "this is second_scope#thingy, the final destination of the $dynamicRef",
          $dynamicAnchor: "thingy",
          type: "null",
        },
      },
    },
    $defs: {
      start: {
        $comment: "this is the landing spot from $ref",
        $id: "start",
        $dynamicRef: "inner_scope#thingy",
      },
      thingy: {
        $comment: "this is the first stop for the $dynamicRef",
        $id: "inner_scope",
        $dynamicAnchor: "thingy",
        type: "string",
      },
    },
  };
  test("string matches /$defs/thingy, but the $dynamicRef does not stop here", () => {
    const instance = new Schema(schema);
    expect(instance.validate("a string")).toBeFalsy();
  });
  test("first_scope is not in dynamic scope for the $dynamicRef", () => {
    const instance = new Schema(schema);
    expect(instance.validate(42)).toBeFalsy();
  });
  test("/then/$defs/thingy is the final stop for the $dynamicRef", () => {
    const instance = new Schema(schema);
    expect(instance.validate(null)).toBeTruthy();
  });
});
describe("strict-tree schema, guards against misspelled properties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "http://localhost:1234/draft2020-12/strict-tree.json",
    $dynamicAnchor: "node",
    $ref: "tree.json",
    unevaluatedProperties: false,
  };
  test("instance with misspelled field", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ children: [{ daat: 1 }] })).toBeFalsy();
  });
  test("instance with correct field", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ children: [{ data: 1 }] })).toBeTruthy();
  });
});
describe("tests for implementation dynamic anchor and reference link", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "http://localhost:1234/draft2020-12/strict-extendible.json",
    $ref: "extendible-dynamic-ref.json",
    $defs: {
      elements: {
        $dynamicAnchor: "elements",
        properties: { a: true },
        required: ["a"],
        additionalProperties: false,
      },
    },
  };
  test("incorrect parent schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: true })).toBeFalsy();
  });
  test("incorrect extended schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ elements: [{ b: 1 }] })).toBeFalsy();
  });
  test("correct extended schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ elements: [{ a: 1 }] })).toBeTruthy();
  });
});
describe("$ref and $dynamicAnchor are independent of order - $defs first", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "http://localhost:1234/draft2020-12/strict-extendible-allof-defs-first.json",
    allOf: [
      { $ref: "extendible-dynamic-ref.json" },
      {
        $defs: {
          elements: {
            $dynamicAnchor: "elements",
            properties: { a: true },
            required: ["a"],
            additionalProperties: false,
          },
        },
      },
    ],
  };
  test("incorrect parent schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: true })).toBeFalsy();
  });
  test("incorrect extended schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ elements: [{ b: 1 }] })).toBeFalsy();
  });
  test("correct extended schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ elements: [{ a: 1 }] })).toBeTruthy();
  });
});
describe("$ref and $dynamicAnchor are independent of order - $ref first", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "http://localhost:1234/draft2020-12/strict-extendible-allof-ref-first.json",
    allOf: [
      {
        $defs: {
          elements: {
            $dynamicAnchor: "elements",
            properties: { a: true },
            required: ["a"],
            additionalProperties: false,
          },
        },
      },
      { $ref: "extendible-dynamic-ref.json" },
    ],
  };
  test("incorrect parent schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: true })).toBeFalsy();
  });
  test("incorrect extended schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ elements: [{ b: 1 }] })).toBeFalsy();
  });
  test("correct extended schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ elements: [{ a: 1 }] })).toBeTruthy();
  });
});
describe("$ref to $dynamicRef finds detached $dynamicAnchor", () => {
  const schema = {
    $ref: "http://localhost:1234/draft2020-12/detached-dynamicref.json#/$defs/foo",
  };
  test("number is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate(1)).toBeTruthy();
  });
  test("non-number is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate("a")).toBeFalsy();
  });
});
describe("$dynamicRef points to a boolean schema", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $defs: { true: true, false: false },
    properties: {
      true: { $dynamicRef: "#/$defs/true" },
      false: { $dynamicRef: "#/$defs/false" },
    },
  };
  test("follow $dynamicRef to a true schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ true: 1 })).toBeTruthy();
  });
  test("follow $dynamicRef to a false schema", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ false: 1 })).toBeFalsy();
  });
});
describe("$dynamicRef skips over intermediate resources - direct reference", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://test.json-schema.org/dynamic-ref-skips-intermediate-resource/main",
    type: "object",
    properties: { "bar-item": { $ref: "item" } },
    $defs: {
      bar: {
        $id: "bar",
        type: "array",
        items: { $ref: "item" },
        $defs: {
          item: {
            $id: "item",
            type: "object",
            properties: { content: { $dynamicRef: "#content" } },
            $defs: {
              defaultContent: { $dynamicAnchor: "content", type: "integer" },
            },
          },
          content: { $dynamicAnchor: "content", type: "string" },
        },
      },
    },
  };
  test("integer property passes", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ "bar-item": { content: 42 } })).toBeTruthy();
  });
  test("string property fails", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ "bar-item": { content: "value" } })).toBeFalsy();
  });
});
