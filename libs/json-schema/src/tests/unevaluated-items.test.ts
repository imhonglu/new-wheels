/* This file is automatically generated. Do not edit this file. */
import { describe, expect, test } from "vitest";
import { Schema } from "../schema.js";
describe("unevaluatedItems true", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		unevaluatedItems: true,
	};
	test("with no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate([])).toBeTruthy();
	});
	test("with unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo"])).toBeTruthy();
	});
});
describe("unevaluatedItems false", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		unevaluatedItems: false,
	};
	test("with no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate([])).toBeTruthy();
	});
	test("with unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo"])).toBeFalsy();
	});
});
describe("unevaluatedItems as schema", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		unevaluatedItems: { type: "string" },
	};
	test("with no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate([])).toBeTruthy();
	});
	test("with valid unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo"])).toBeTruthy();
	});
	test("with invalid unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate([42])).toBeFalsy();
	});
});
describe("unevaluatedItems with uniform items", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		items: { type: "string" },
		unevaluatedItems: false,
	};
	test("unevaluatedItems doesn't apply", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar"])).toBeTruthy();
	});
});
describe("unevaluatedItems with tuple", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		prefixItems: [{ type: "string" }],
		unevaluatedItems: false,
	};
	test("with no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo"])).toBeTruthy();
	});
	test("with unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar"])).toBeFalsy();
	});
});
describe("unevaluatedItems with items and prefixItems", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		prefixItems: [{ type: "string" }],
		items: true,
		unevaluatedItems: false,
	};
	test("unevaluatedItems doesn't apply", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", 42])).toBeTruthy();
	});
});
describe("unevaluatedItems with items", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		items: { type: "number" },
		unevaluatedItems: { type: "string" },
	};
	test("valid under items", () => {
		const instance = new Schema(schema);
		expect(instance.validate([5, 6, 7, 8])).toBeTruthy();
	});
	test("invalid under items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar", "baz"])).toBeFalsy();
	});
});
describe("unevaluatedItems with nested tuple", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		prefixItems: [{ type: "string" }],
		allOf: [{ prefixItems: [true, { type: "number" }] }],
		unevaluatedItems: false,
	};
	test("with no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", 42])).toBeTruthy();
	});
	test("with unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", 42, true])).toBeFalsy();
	});
});
describe("unevaluatedItems with nested items", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		unevaluatedItems: { type: "boolean" },
		anyOf: [{ items: { type: "string" } }, true],
	};
	test("with only (valid) additional items", () => {
		const instance = new Schema(schema);
		expect(instance.validate([true, false])).toBeTruthy();
	});
	test("with no additional items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["yes", "no"])).toBeTruthy();
	});
	test("with invalid additional item", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["yes", false])).toBeFalsy();
	});
});
describe("unevaluatedItems with nested prefixItems and items", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		allOf: [{ prefixItems: [{ type: "string" }], items: true }],
		unevaluatedItems: false,
	};
	test("with no additional items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo"])).toBeTruthy();
	});
	test("with additional items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", 42, true])).toBeTruthy();
	});
});
describe("unevaluatedItems with nested unevaluatedItems", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		allOf: [{ prefixItems: [{ type: "string" }] }, { unevaluatedItems: true }],
		unevaluatedItems: false,
	};
	test("with no additional items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo"])).toBeTruthy();
	});
	test("with additional items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", 42, true])).toBeTruthy();
	});
});
describe("unevaluatedItems with anyOf", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		prefixItems: [{ const: "foo" }],
		anyOf: [
			{ prefixItems: [true, { const: "bar" }] },
			{ prefixItems: [true, true, { const: "baz" }] },
		],
		unevaluatedItems: false,
	};
	test("when one schema matches and has no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar"])).toBeTruthy();
	});
	test("when one schema matches and has unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar", 42])).toBeFalsy();
	});
	test("when two schemas match and has no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar", "baz"])).toBeTruthy();
	});
	test("when two schemas match and has unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar", "baz", 42])).toBeFalsy();
	});
});
describe("unevaluatedItems with oneOf", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		prefixItems: [{ const: "foo" }],
		oneOf: [
			{ prefixItems: [true, { const: "bar" }] },
			{ prefixItems: [true, { const: "baz" }] },
		],
		unevaluatedItems: false,
	};
	test("with no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar"])).toBeTruthy();
	});
	test("with unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar", 42])).toBeFalsy();
	});
});
describe("unevaluatedItems with not", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		prefixItems: [{ const: "foo" }],
		not: { not: { prefixItems: [true, { const: "bar" }] } },
		unevaluatedItems: false,
	};
	test("with unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar"])).toBeFalsy();
	});
});
describe("unevaluatedItems with if/then/else", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		prefixItems: [{ const: "foo" }],
		if: { prefixItems: [true, { const: "bar" }] },
		then: { prefixItems: [true, true, { const: "then" }] },
		else: { prefixItems: [true, true, true, { const: "else" }] },
		unevaluatedItems: false,
	};
	test("when if matches and it has no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar", "then"])).toBeTruthy();
	});
	test("when if matches and it has unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar", "then", "else"])).toBeFalsy();
	});
	test("when if doesn't match and it has no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", 42, 42, "else"])).toBeTruthy();
	});
	test("when if doesn't match and it has unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", 42, 42, "else", 42])).toBeFalsy();
	});
});
describe("unevaluatedItems with boolean schemas", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		allOf: [true],
		unevaluatedItems: false,
	};
	test("with no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate([])).toBeTruthy();
	});
	test("with unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo"])).toBeFalsy();
	});
});
describe("unevaluatedItems with $ref", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		$ref: "#/$defs/bar",
		prefixItems: [{ type: "string" }],
		unevaluatedItems: false,
		$defs: { bar: { prefixItems: [true, { type: "string" }] } },
	};
	test("with no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar"])).toBeTruthy();
	});
	test("with unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar", "baz"])).toBeFalsy();
	});
});
describe("unevaluatedItems before $ref", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		unevaluatedItems: false,
		prefixItems: [{ type: "string" }],
		$ref: "#/$defs/bar",
		$defs: { bar: { prefixItems: [true, { type: "string" }] } },
	};
	test("with no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar"])).toBeTruthy();
	});
	test("with unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar", "baz"])).toBeFalsy();
	});
});
describe("unevaluatedItems with $dynamicRef", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		$id: "https://example.com/unevaluated-items-with-dynamic-ref/derived",
		$ref: "./baseSchema",
		$defs: {
			derived: {
				$dynamicAnchor: "addons",
				prefixItems: [true, { type: "string" }],
			},
			baseSchema: {
				$id: "./baseSchema",
				$comment:
					"unevaluatedItems comes first so it's more likely to catch bugs with implementations that are sensitive to keyword ordering",
				unevaluatedItems: false,
				type: "array",
				prefixItems: [{ type: "string" }],
				$dynamicRef: "#addons",
				$defs: {
					defaultAddons: {
						$comment: "Needed to satisfy the bookending requirement",
						$dynamicAnchor: "addons",
					},
				},
			},
		},
	};
	test("with no unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar"])).toBeTruthy();
	});
	test("with unevaluated items", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["foo", "bar", "baz"])).toBeFalsy();
	});
});
describe("unevaluatedItems can't see inside cousins", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		allOf: [{ prefixItems: [true] }, { unevaluatedItems: false }],
	};
	test("always fails", () => {
		const instance = new Schema(schema);
		expect(instance.validate([1])).toBeFalsy();
	});
});
describe("item is evaluated in an uncle schema to unevaluatedItems", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		properties: {
			foo: { prefixItems: [{ type: "string" }], unevaluatedItems: false },
		},
		anyOf: [
			{ properties: { foo: { prefixItems: [true, { type: "string" }] } } },
		],
	};
	test("no extra items", () => {
		const instance = new Schema(schema);
		expect(instance.validate({ foo: ["test"] })).toBeTruthy();
	});
	test("uncle keyword evaluation is not significant", () => {
		const instance = new Schema(schema);
		expect(instance.validate({ foo: ["test", "test"] })).toBeFalsy();
	});
});
describe("unevaluatedItems depends on adjacent contains", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		prefixItems: [true],
		contains: { type: "string" },
		unevaluatedItems: false,
	};
	test("second item is evaluated by contains", () => {
		const instance = new Schema(schema);
		expect(instance.validate([1, "foo"])).toBeTruthy();
	});
	test("contains fails, second item is not evaluated", () => {
		const instance = new Schema(schema);
		expect(instance.validate([1, 2])).toBeFalsy();
	});
	test("contains passes, second item is not evaluated", () => {
		const instance = new Schema(schema);
		expect(instance.validate([1, 2, "foo"])).toBeFalsy();
	});
});
describe("unevaluatedItems depends on multiple nested contains", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		allOf: [{ contains: { multipleOf: 2 } }, { contains: { multipleOf: 3 } }],
		unevaluatedItems: { multipleOf: 5 },
	};
	test("5 not evaluated, passes unevaluatedItems", () => {
		const instance = new Schema(schema);
		expect(instance.validate([2, 3, 4, 5, 6])).toBeTruthy();
	});
	test("7 not evaluated, fails unevaluatedItems", () => {
		const instance = new Schema(schema);
		expect(instance.validate([2, 3, 4, 7, 8])).toBeFalsy();
	});
});
describe("unevaluatedItems and contains interact to control item dependency relationship", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		if: { contains: { const: "a" } },
		then: {
			if: { contains: { const: "b" } },
			then: { if: { contains: { const: "c" } } },
		},
		unevaluatedItems: false,
	};
	test("empty array is valid", () => {
		const instance = new Schema(schema);
		expect(instance.validate([])).toBeTruthy();
	});
	test("only a's are valid", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["a", "a"])).toBeTruthy();
	});
	test("a's and b's are valid", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["a", "b", "a", "b", "a"])).toBeTruthy();
	});
	test("a's, b's and c's are valid", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["c", "a", "c", "c", "b", "a"])).toBeTruthy();
	});
	test("only b's are invalid", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["b", "b"])).toBeFalsy();
	});
	test("only c's are invalid", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["c", "c"])).toBeFalsy();
	});
	test("only b's and c's are invalid", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["c", "b", "c", "b", "c"])).toBeFalsy();
	});
	test("only a's and c's are invalid", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["c", "a", "c", "a", "c"])).toBeFalsy();
	});
});
describe("non-array instances are valid", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		unevaluatedItems: false,
	};
	test("ignores booleans", () => {
		const instance = new Schema(schema);
		expect(instance.validate(true)).toBeTruthy();
	});
	test("ignores integers", () => {
		const instance = new Schema(schema);
		expect(instance.validate(123)).toBeTruthy();
	});
	test("ignores floats", () => {
		const instance = new Schema(schema);
		expect(instance.validate(1)).toBeTruthy();
	});
	test("ignores objects", () => {
		const instance = new Schema(schema);
		expect(instance.validate({})).toBeTruthy();
	});
	test("ignores strings", () => {
		const instance = new Schema(schema);
		expect(instance.validate("foo")).toBeTruthy();
	});
	test("ignores null", () => {
		const instance = new Schema(schema);
		expect(instance.validate(null)).toBeTruthy();
	});
});
describe("unevaluatedItems with null instance elements", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		unevaluatedItems: { type: "null" },
	};
	test("allows null elements", () => {
		const instance = new Schema(schema);
		expect(instance.validate([null])).toBeTruthy();
	});
});
describe("unevaluatedItems can see annotations from if without then and else", () => {
	const schema = {
		$schema: "https://json-schema.org/draft/2020-12/schema",
		if: { prefixItems: [{ const: "a" }] },
		unevaluatedItems: false,
	};
	test("valid in case if is evaluated", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["a"])).toBeTruthy();
	});
	test("invalid in case if is evaluated", () => {
		const instance = new Schema(schema);
		expect(instance.validate(["b"])).toBeFalsy();
	});
});
