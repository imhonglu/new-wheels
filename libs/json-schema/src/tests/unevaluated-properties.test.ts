/* This file is automatically generated. Do not edit this file. */
import { describe, expect, test } from "vitest";
import { Schema } from "../schema.js";
describe("unevaluatedProperties true", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    unevaluatedProperties: true,
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({})).toBeTruthy();
  });
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
});
describe("unevaluatedProperties schema", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    unevaluatedProperties: { type: "string", minLength: 3 },
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({})).toBeTruthy();
  });
  test("with valid unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with invalid unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "fo" })).toBeFalsy();
  });
});
describe("unevaluatedProperties false", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    unevaluatedProperties: false,
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({})).toBeTruthy();
  });
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeFalsy();
  });
});
describe("unevaluatedProperties with adjacent properties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    unevaluatedProperties: false,
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeFalsy();
  });
});
describe("unevaluatedProperties with adjacent patternProperties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    patternProperties: { "^foo": { type: "string" } },
    unevaluatedProperties: false,
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeFalsy();
  });
});
describe("unevaluatedProperties with adjacent additionalProperties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    additionalProperties: true,
    unevaluatedProperties: false,
  };
  test("with no additional properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with additional properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
});
describe("unevaluatedProperties with nested properties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    allOf: [{ properties: { bar: { type: "string" } } }],
    unevaluatedProperties: false,
  };
  test("with no additional properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
  test("with additional properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "foo", bar: "bar", baz: "baz" }),
    ).toBeFalsy();
  });
});
describe("unevaluatedProperties with nested patternProperties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    allOf: [{ patternProperties: { "^bar": { type: "string" } } }],
    unevaluatedProperties: false,
  };
  test("with no additional properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
  test("with additional properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "foo", bar: "bar", baz: "baz" }),
    ).toBeFalsy();
  });
});
describe("unevaluatedProperties with nested additionalProperties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    allOf: [{ additionalProperties: true }],
    unevaluatedProperties: false,
  };
  test("with no additional properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with additional properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
});
describe("unevaluatedProperties with nested unevaluatedProperties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    allOf: [{ unevaluatedProperties: true }],
    unevaluatedProperties: { type: "string", maxLength: 2 },
  };
  test("with no nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
});
describe("unevaluatedProperties with anyOf", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    anyOf: [
      { properties: { bar: { const: "bar" } }, required: ["bar"] },
      { properties: { baz: { const: "baz" } }, required: ["baz"] },
      { properties: { quux: { const: "quux" } }, required: ["quux"] },
    ],
    unevaluatedProperties: false,
  };
  test("when one matches and has no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
  test("when one matches and has unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "foo", bar: "bar", baz: "not-baz" }),
    ).toBeFalsy();
  });
  test("when two match and has no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "foo", bar: "bar", baz: "baz" }),
    ).toBeTruthy();
  });
  test("when two match and has unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({
        foo: "foo",
        bar: "bar",
        baz: "baz",
        quux: "not-quux",
      }),
    ).toBeFalsy();
  });
});
describe("unevaluatedProperties with oneOf", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    oneOf: [
      { properties: { bar: { const: "bar" } }, required: ["bar"] },
      { properties: { baz: { const: "baz" } }, required: ["baz"] },
    ],
    unevaluatedProperties: false,
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "foo", bar: "bar", quux: "quux" }),
    ).toBeFalsy();
  });
});
describe("unevaluatedProperties with not", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    not: { not: { properties: { bar: { const: "bar" } }, required: ["bar"] } },
    unevaluatedProperties: false,
  };
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeFalsy();
  });
});
describe("unevaluatedProperties with if/then/else", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    if: { properties: { foo: { const: "then" } }, required: ["foo"] },
    then: { properties: { bar: { type: "string" } }, required: ["bar"] },
    else: { properties: { baz: { type: "string" } }, required: ["baz"] },
    unevaluatedProperties: false,
  };
  test("when if is true and has no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "then", bar: "bar" })).toBeTruthy();
  });
  test("when if is true and has unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "then", bar: "bar", baz: "baz" }),
    ).toBeFalsy();
  });
  test("when if is false and has no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ baz: "baz" })).toBeTruthy();
  });
  test("when if is false and has unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "else", baz: "baz" })).toBeFalsy();
  });
});
describe("unevaluatedProperties with if/then/else, then not defined", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    if: { properties: { foo: { const: "then" } }, required: ["foo"] },
    else: { properties: { baz: { type: "string" } }, required: ["baz"] },
    unevaluatedProperties: false,
  };
  test("when if is true and has no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "then", bar: "bar" })).toBeFalsy();
  });
  test("when if is true and has unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "then", bar: "bar", baz: "baz" }),
    ).toBeFalsy();
  });
  test("when if is false and has no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ baz: "baz" })).toBeTruthy();
  });
  test("when if is false and has unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "else", baz: "baz" })).toBeFalsy();
  });
});
describe("unevaluatedProperties with if/then/else, else not defined", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    if: { properties: { foo: { const: "then" } }, required: ["foo"] },
    then: { properties: { bar: { type: "string" } }, required: ["bar"] },
    unevaluatedProperties: false,
  };
  test("when if is true and has no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "then", bar: "bar" })).toBeTruthy();
  });
  test("when if is true and has unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "then", bar: "bar", baz: "baz" }),
    ).toBeFalsy();
  });
  test("when if is false and has no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ baz: "baz" })).toBeFalsy();
  });
  test("when if is false and has unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "else", baz: "baz" })).toBeFalsy();
  });
});
describe("unevaluatedProperties with dependentSchemas", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    dependentSchemas: {
      foo: { properties: { bar: { const: "bar" } }, required: ["bar"] },
    },
    unevaluatedProperties: false,
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ bar: "bar" })).toBeFalsy();
  });
});
describe("unevaluatedProperties with boolean schemas", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    allOf: [true],
    unevaluatedProperties: false,
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ bar: "bar" })).toBeFalsy();
  });
});
describe("unevaluatedProperties with $ref", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    $ref: "#/$defs/bar",
    properties: { foo: { type: "string" } },
    unevaluatedProperties: false,
    $defs: { bar: { properties: { bar: { type: "string" } } } },
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "foo", bar: "bar", baz: "baz" }),
    ).toBeFalsy();
  });
});
describe("unevaluatedProperties before $ref", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    unevaluatedProperties: false,
    properties: { foo: { type: "string" } },
    $ref: "#/$defs/bar",
    $defs: { bar: { properties: { bar: { type: "string" } } } },
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "foo", bar: "bar", baz: "baz" }),
    ).toBeFalsy();
  });
});
describe("unevaluatedProperties with $dynamicRef", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $id: "https://example.com/unevaluated-properties-with-dynamic-ref/derived",
    $ref: "./baseSchema",
    $defs: {
      derived: {
        $dynamicAnchor: "addons",
        properties: { bar: { type: "string" } },
      },
      baseSchema: {
        $id: "./baseSchema",
        $comment:
          "unevaluatedProperties comes first so it's more likely to catch bugs with implementations that are sensitive to keyword ordering",
        unevaluatedProperties: false,
        type: "object",
        properties: { foo: { type: "string" } },
        $dynamicRef: "#addons",
        $defs: {
          defaultAddons: {
            $comment: "Needed to satisfy the bookending requirement",
            $dynamicAnchor: "addons",
          },
        },
      },
    },
  };
  test("with no unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
  test("with unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: "foo", bar: "bar", baz: "baz" }),
    ).toBeFalsy();
  });
});
describe("unevaluatedProperties can't see inside cousins", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    allOf: [{ properties: { foo: true } }, { unevaluatedProperties: false }],
  };
  test("always fails", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: 1 })).toBeFalsy();
  });
});
describe("unevaluatedProperties can't see inside cousins (reverse order)", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    allOf: [{ unevaluatedProperties: false }, { properties: { foo: true } }],
  };
  test("always fails", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: 1 })).toBeFalsy();
  });
});
describe("nested unevaluatedProperties, outer false, inner true, properties outside", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    allOf: [{ unevaluatedProperties: true }],
    unevaluatedProperties: false,
  };
  test("with no nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
});
describe("nested unevaluatedProperties, outer false, inner true, properties inside", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    allOf: [
      { properties: { foo: { type: "string" } }, unevaluatedProperties: true },
    ],
    unevaluatedProperties: false,
  };
  test("with no nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeTruthy();
  });
});
describe("nested unevaluatedProperties, outer true, inner false, properties outside", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { foo: { type: "string" } },
    allOf: [{ unevaluatedProperties: false }],
    unevaluatedProperties: true,
  };
  test("with no nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeFalsy();
  });
  test("with nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeFalsy();
  });
});
describe("nested unevaluatedProperties, outer true, inner false, properties inside", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    allOf: [
      { properties: { foo: { type: "string" } }, unevaluatedProperties: false },
    ],
    unevaluatedProperties: true,
  };
  test("with no nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeFalsy();
  });
});
describe("cousin unevaluatedProperties, true and false, true with properties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    allOf: [
      { properties: { foo: { type: "string" } }, unevaluatedProperties: true },
      { unevaluatedProperties: false },
    ],
  };
  test("with no nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeFalsy();
  });
  test("with nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeFalsy();
  });
});
describe("cousin unevaluatedProperties, true and false, false with properties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    allOf: [
      { unevaluatedProperties: true },
      { properties: { foo: { type: "string" } }, unevaluatedProperties: false },
    ],
  };
  test("with no nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo" })).toBeTruthy();
  });
  test("with nested unevaluated properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "foo", bar: "bar" })).toBeFalsy();
  });
});
describe("property is evaluated in an uncle schema to unevaluatedProperties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: {
      foo: {
        type: "object",
        properties: { bar: { type: "string" } },
        unevaluatedProperties: false,
      },
    },
    anyOf: [
      { properties: { foo: { properties: { faz: { type: "string" } } } } },
    ],
  };
  test("no extra properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: { bar: "test" } })).toBeTruthy();
  });
  test("uncle keyword evaluation is not significant", () => {
    const instance = new Schema(schema);
    expect(
      instance.validate({ foo: { bar: "test", faz: "test" } }),
    ).toBeFalsy();
  });
});
describe("in-place applicator siblings, allOf has unevaluated", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    allOf: [{ properties: { foo: true }, unevaluatedProperties: false }],
    anyOf: [{ properties: { bar: true } }],
  };
  test("base case: both properties present", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: 1, bar: 1 })).toBeFalsy();
  });
  test("in place applicator siblings, bar is missing", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: 1 })).toBeTruthy();
  });
  test("in place applicator siblings, foo is missing", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ bar: 1 })).toBeFalsy();
  });
});
describe("in-place applicator siblings, anyOf has unevaluated", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    allOf: [{ properties: { foo: true } }],
    anyOf: [{ properties: { bar: true }, unevaluatedProperties: false }],
  };
  test("base case: both properties present", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: 1, bar: 1 })).toBeFalsy();
  });
  test("in place applicator siblings, bar is missing", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: 1 })).toBeFalsy();
  });
  test("in place applicator siblings, foo is missing", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ bar: 1 })).toBeTruthy();
  });
});
describe("unevaluatedProperties + single cyclic ref", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    type: "object",
    properties: { x: { $ref: "#" } },
    unevaluatedProperties: false,
  };
  test("Empty is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({})).toBeTruthy();
  });
  test("Single is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ x: {} })).toBeTruthy();
  });
  test("Unevaluated on 1st level is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ x: {}, y: {} })).toBeFalsy();
  });
  test("Nested is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ x: { x: {} } })).toBeTruthy();
  });
  test("Unevaluated on 2nd level is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ x: { x: {}, y: {} } })).toBeFalsy();
  });
  test("Deep nested is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ x: { x: { x: {} } } })).toBeTruthy();
  });
  test("Unevaluated on 3rd level is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ x: { x: { x: {}, y: {} } } })).toBeFalsy();
  });
});
describe("unevaluatedProperties + ref inside allOf / oneOf", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $defs: {
      one: { properties: { a: true } },
      two: { required: ["x"], properties: { x: true } },
    },
    allOf: [
      { $ref: "#/$defs/one" },
      { properties: { b: true } },
      {
        oneOf: [
          { $ref: "#/$defs/two" },
          { required: ["y"], properties: { y: true } },
        ],
      },
    ],
    unevaluatedProperties: false,
  };
  test("Empty is invalid (no x or y)", () => {
    const instance = new Schema(schema);
    expect(instance.validate({})).toBeFalsy();
  });
  test("a and b are invalid (no x or y)", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1, b: 1 })).toBeFalsy();
  });
  test("x and y are invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ x: 1, y: 1 })).toBeFalsy();
  });
  test("a and x are valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1, x: 1 })).toBeTruthy();
  });
  test("a and y are valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1, y: 1 })).toBeTruthy();
  });
  test("a and b and x are valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1, b: 1, x: 1 })).toBeTruthy();
  });
  test("a and b and y are valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1, b: 1, y: 1 })).toBeTruthy();
  });
  test("a and b and x and y are invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1, b: 1, x: 1, y: 1 })).toBeFalsy();
  });
});
describe("dynamic evalation inside nested refs", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    $defs: {
      one: {
        oneOf: [
          { $ref: "#/$defs/two" },
          { required: ["b"], properties: { b: true } },
          { required: ["xx"], patternProperties: { x: true } },
          { required: ["all"], unevaluatedProperties: true },
        ],
      },
      two: {
        oneOf: [
          { required: ["c"], properties: { c: true } },
          { required: ["d"], properties: { d: true } },
        ],
      },
    },
    oneOf: [
      { $ref: "#/$defs/one" },
      { required: ["a"], properties: { a: true } },
    ],
    unevaluatedProperties: false,
  };
  test("Empty is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({})).toBeFalsy();
  });
  test("a is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1 })).toBeTruthy();
  });
  test("b is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ b: 1 })).toBeTruthy();
  });
  test("c is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ c: 1 })).toBeTruthy();
  });
  test("d is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ d: 1 })).toBeTruthy();
  });
  test("a + b is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1, b: 1 })).toBeFalsy();
  });
  test("a + c is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1, c: 1 })).toBeFalsy();
  });
  test("a + d is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1, d: 1 })).toBeFalsy();
  });
  test("b + c is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ b: 1, c: 1 })).toBeFalsy();
  });
  test("b + d is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ b: 1, d: 1 })).toBeFalsy();
  });
  test("c + d is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ c: 1, d: 1 })).toBeFalsy();
  });
  test("xx is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ xx: 1 })).toBeTruthy();
  });
  test("xx + foox is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ xx: 1, foox: 1 })).toBeTruthy();
  });
  test("xx + foo is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ xx: 1, foo: 1 })).toBeFalsy();
  });
  test("xx + a is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ xx: 1, a: 1 })).toBeFalsy();
  });
  test("xx + b is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ xx: 1, b: 1 })).toBeFalsy();
  });
  test("xx + c is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ xx: 1, c: 1 })).toBeFalsy();
  });
  test("xx + d is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ xx: 1, d: 1 })).toBeFalsy();
  });
  test("all is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ all: 1 })).toBeTruthy();
  });
  test("all + foo is valid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ all: 1, foo: 1 })).toBeTruthy();
  });
  test("all + a is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ all: 1, a: 1 })).toBeFalsy();
  });
});
describe("non-object instances are valid", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    unevaluatedProperties: false,
  };
  test("ignores booleans", () => {
    const instance = new Schema(schema);
    expect(instance.validate(true)).toBeTruthy();
  });
  test("ignores integers", () => {
    const instance = new Schema(schema);
    expect(instance.validate(123)).toBeTruthy();
  });
  test("ignores floats", () => {
    const instance = new Schema(schema);
    expect(instance.validate(1)).toBeTruthy();
  });
  test("ignores arrays", () => {
    const instance = new Schema(schema);
    expect(instance.validate([])).toBeTruthy();
  });
  test("ignores strings", () => {
    const instance = new Schema(schema);
    expect(instance.validate("foo")).toBeTruthy();
  });
  test("ignores null", () => {
    const instance = new Schema(schema);
    expect(instance.validate(null)).toBeTruthy();
  });
});
describe("unevaluatedProperties with null valued instance properties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    unevaluatedProperties: { type: "null" },
  };
  test("allows null valued properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: null })).toBeTruthy();
  });
});
describe("unevaluatedProperties not affected by propertyNames", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    propertyNames: { maxLength: 1 },
    unevaluatedProperties: { type: "number" },
  };
  test("allows only number properties", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: 1 })).toBeTruthy();
  });
  test("string property is invalid", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ a: "b" })).toBeFalsy();
  });
});
describe("unevaluatedProperties can see annotations from if without then and else", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    if: { patternProperties: { foo: { type: "string" } } },
    unevaluatedProperties: false,
  };
  test("valid in case if is evaluated", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "a" })).toBeTruthy();
  });
  test("invalid in case if is evaluated", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ bar: "a" })).toBeFalsy();
  });
});
describe("dependentSchemas with unevaluatedProperties", () => {
  const schema = {
    $schema: "https://json-schema.org/draft/2020-12/schema",
    properties: { foo2: {} },
    dependentSchemas: { foo: {}, foo2: { properties: { bar: {} } } },
    unevaluatedProperties: false,
  };
  test("unevaluatedProperties doesn't consider dependentSchemas", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo: "" })).toBeFalsy();
  });
  test("unevaluatedProperties doesn't see bar when foo2 is absent", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ bar: "" })).toBeFalsy();
  });
  test("unevaluatedProperties sees bar when foo2 is present", () => {
    const instance = new Schema(schema);
    expect(instance.validate({ foo2: "", bar: "" })).toBeTruthy();
  });
});
